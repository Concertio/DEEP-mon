# Performance Monitoring
Two kinds of performance events:
- **Architectural:** Compatible among different processor families, registers addresses remain the same across different microarchitectures
- **Non architectural:** Model specific

#### Classes of performance monitoring capabilities
1) First class, supports events for monitoring performance using counting
2) Second class, supports interrupt-based event sampling

The two classes are valid for both *architectural* and *non-architectural* event types, the former having a smaller set of available events

## Architectural Performance Monitoring
Intel hardware provides mechanism for software to:
- **Enumerate** performance events
- Access **configuration** and **counting** facilities for events

#### Configuration
Configuring an architectural **Performance Monitoring Event (PME)** involves programming **Performance Event Select Registers (PESR)**. There are a couple of things to take into account regarding performance events monitoring:
- There is a finite number of *Performance Event Select Registers* (MSRs) [IA32_PERFEVTSELx MSRs]
- The result of a PME is reported in a **Performance Monitoring Counter (PMC)** [IA32_PMCx MSR]
- PMCs are paired with *Performance Monitoring Select Registers*

**N.B.** Each logical processor has its own set of IA32_PERFEVTSELx and IA32_PMCx MSRs. Configuration facilities and counters are not shared between logical processors sharing a processor core.

#### Find the number of available PMCs
Each CPU has a limited number of PMC, if you are interested into knowing which is this number you can use `cpuid` (included in msr-tools or available as standalone tool).
The only argument it expects is the id number of the CPU (core) you want to analyze, the default is 0.

Let's run `sudo cpuid` and take a look at the output of the command:
```
Leaf     Subleaf    EAX            EBX            ECX            EDX
00000000 00000000:  0000000d ....  756e6547 Genu  6c65746e ntel  49656e69 ineI
00000001 00000000:  000306a9 ....  01100800 ....  7fbae3ff ....  bfebfbff ....
00000002 00000000:  76035a01 .Z.v  00f0b2ff ....  00000000 ....  00ca0000 ....
00000003 00000000:  00000000 ....  00000000 ....  00000000 ....  00000000 ....
00000004 00000000:  1c004121 !A..  01c0003f ?...  0000003f ?...  00000000 ....
00000004 00000001:  1c004122 "A..  01c0003f ?...  0000003f ?...  00000000 ....
00000004 00000002:  1c004143 CA..  01c0003f ?...  000001ff ....  00000000 ....
00000004 00000003:  1c03c163 c...  02c0003f ?...  00000fff ....  00000006 ....
00000005 00000000:  00000040 @...  00000040 @...  00000003 ....  00021120  ...
00000006 00000000:  00000077 w...  00000002 ....  00000009 ....  00000000 ....
00000007 00000000:  00000000 ....  00000281 ....  00000000 ....  00000000 ....
00000008 00000000:  00000000 ....  00000000 ....  00000000 ....  00000000 ....
00000009 00000000:  00000000 ....  00000000 ....  00000000 ....  00000000 ....
0000000a 00000000:  07300403 ..0.  00000000 ....  00000000 ....  00000603 ....
0000000b 00000000:  00000001 ....  00000002 ....  00000100 ....  00000001 ....
0000000b 00000001:  00000004 ....  00000004 ....  00000201 ....  00000001 ....
0000000c 00000000:  00000000 ....  00000000 ....  00000000 ....  00000000 ....
0000000d 00000000:  00000007 ....  00000340 @...  00000340 @...  00000000 ....
0000000d 00000001:  00000001 ....  00000000 ....  00000000 ....  00000000 ....
0000000d 00000002:  00000100 ....  00000240 @...  00000000 ....  00000000 ....
80000000 00000000:  80000008 ....  00000000 ....  00000000 ....  00000000 ....
80000001 00000000:  00000000 ....  00000000 ....  00000001 ....  28100800 ...(
80000002 00000000:  20202020       49202020    I  6c65746e ntel  20295228 (R)
80000003 00000000:  65726f43 Core  294d5428 (TM)  2d356920  i5-  30323333 3320
80000004 00000000:  5043204d M CP  20402055 U @   30362e32 2.60  007a4847 GHz.
80000005 00000000:  00000000 ....  00000000 ....  00000000 ....  00000000 ....
80000006 00000000:  00000000 ....  00000000 ....  01006040 @`..  00000000 ....
80000007 00000000:  00000000 ....  00000000 ....  00000000 ....  00000100 ....
80000008 00000000:  00003024 $0..  00000000 ....  00000000 ....  00000000 ....
```

The way to extract PMC information from `cpuid` is described in chapter 18.2.1.1 of the *IntelÂ® 64 and IA-32 Architectures Software Developerâ€™s Manual Volume 3*.
According to the manual, the Leaf we are interested in is `0AH (0000000a)` and the information about how many PMCs are available in our architecture can be read from bits [15:8] of the EAX register.

Let's inspect the correct line using command
```
sudo cpuid | awk 'NR==1 || /0a/'
```
The hexadecimal value of the EAX register is `07300403`, let's extract bits [15:8] from it and convert the resulting value into a decimal number using `python`
```
>>> int(bin(int(0x07300403))[-15:-8], base=2)
4
```
In our case we have four PMC registers available to count performance events.
